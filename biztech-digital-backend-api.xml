This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app.js
Digitize and Market Your Biz API Endpoints.md
package.json
readme.md
src/api/admin.routes.js
src/api/auth.routes.js
src/api/client.routes.js
src/api/project.routes.js
src/api/proposal.routes.js
src/api/request.routes.js
src/config/database.js
src/controllers/admin.controller.js
src/controllers/auth.controller.js
src/controllers/client.controller.js
src/controllers/project.controller.js
src/controllers/proposal.controller.js
src/controllers/request.controller.js
src/middleware/auth.middleware.js
src/middleware/error.middleware.js
src/middleware/upload.middleware.js
src/models/Client.js
src/models/index.js
src/models/Project.js
src/models/ProjectAsset.js
src/models/ProjectNote.js
src/models/Proposal.js
src/models/ProposalLineItem.js
src/models/ServiceCategory.js
src/models/ServiceRequest.js
src/models/User.js
src/services/crypto.service.js
src/services/email.service.js
src/services/pdf.service.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="readme.md">
Create uploads folder and inside it quotations folder, also check env if missing

1: Encryption: technicalVault must never be stored in plain text. Use crypto service (AES-256) in the controller/service layer before DB operations.
2: PDFs: Proposals must generate a physical PDF file stored in uploads/proposals/ upon creation.
3: Gating: The auth.middleware.js or auth.controller.js must strictly enforce the status check for login.
</file>

<file path=".gitignore">
node_modules/
.env
uploads/
*.log
.DS_Store
</file>

<file path="app.js">
require("dotenv").config();
const express = require("express");
const cors = require("cors");
const path = require("path");
const morgan = require("morgan");
const helmet = require("helmet");
const db = require("./src/models");
const { errorMiddleware } = require("./src/middleware/error.middleware");

const app = express();

// Middleware
app.use(helmet()); // Security headers
app.use(cors());   // Allow frontend requests
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan("dev")); // Logger

// Static Folders
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// Basic Route (To test if it works)
app.get("/", (req, res) => {
  res.json({ message: "BizTech API is running..." });
});

app.use("/api/v1/auth", require("./src/api/auth.routes"));
app.use("/api/v1/admin", require("./src/api/admin.routes"));
app.use("/api/v1/clients", require("./src/api/client.routes"));
app.use("/api/v1/requests", require("./src/api/request.routes"));
app.use("/api/v1/proposals", require("./src/api/proposal.routes"));
app.use("/api/v1/projects", require("./src/api/project.routes"));

// Error Handling
app.use(errorMiddleware);

const PORT = process.env.PORT || 3000;

// Sync DB and Start Server
db.sequelize
  .sync({ alter: true }) // 'alter: true' updates tables if you change models
  .then(() => {
    console.log("‚úÖ Database Connected & Synced");
    app.listen(PORT, () => {
      console.log(`üöÄ Server running on port ${PORT}`);
    });
  })
  .catch((err) => console.error("‚ùå Database Connection Failed:", err));
</file>

<file path="Digitize and Market Your Biz API Endpoints.md">
# **Digitize and Market Your Biz API Endpoints**

**Base URL:** http://localhost:3000/api/v1  
**Authentication:** Bearer Token (JWT)  
**Content-Type:** application/json

---

## **1\. Authentication (Gated Access)**

*Implements FR-P-001, FR-P-002*

### **Register User**

**POST** /auth/register

* **Description:** registers a new user. Status defaults to Pending Approval.  
* **Access:** Public

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "fullName": "John Doe",  
  "email": "client@example.com",  
  "password": "password123",  
  "mobile": "+971500000000",  
  "companyName": "My Business LLC", // Creates Client Profile  
  "role": "Client"  
}

*    
* **Response (201):** { "message": "Registration successful. Account pending admin approval." }

### **Login**

**POST** /auth/login

* **Description:** Authenticates user. **Blocker:** Must return error if status is Pending Approval.  
* **Access:** Public  
* **Body:** { "email": "...", "password": "..." }  
* **Response (200):** { "accessToken": "...", "refreshToken": "...", "user": { ... } }  
* **Error (403):** { "message": "Your account is currently under review by an administrator." }

---

## **2\. Admin Oversight** 

*Implements FR-A-001, FR-A-003*

### **Get Pending Approvals**

**GET** /admin/users/pending

* **Description:** List all users waiting for approval.  
* **Access:** Admin  
* **Response (200):** \[ { "id": 1, "fullName": "...", "email": "...", "createdAt": "..." }, ... \]

### **Approve/Reject User**

**PATCH** /admin/users/:id/status

* **Description:** Activates an account or rejects it.  
* **Access:** Admin

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "status": "Active" // or "Rejected"  
}

*    
* **Note:** If "Active", trigger email notification (FR-S-001).

### **Manage Service Categories**

**POST** /admin/categories

* **Description:** Create categories for the Service Request dropdown.  
* **Access:** Admin  
* **Body:** { "name": "SEO Services", "description": "Ranking improvements" }

**GET** /admin/categories

* **Description:** Get list of categories (for frontend dropdowns).  
* **Access:** Authenticated (All roles)

---

## **3\. Client Profile & Technical Vault**

*Implements FR-CL-001, NFR-SE-002*

### **Get My Profile**

**GET** /clients/me

* **Description:** Gets client info including **decrypted** vault data.  
* **Access:** Client

**Response:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "companyName": "...",  
  "technicalVault": "User: admin / Pass: 1234 (Decrypted)"  
}

*  

### **Update Profile & Vault**

**PUT** /clients/me

* **Description:** Updates profile. Backend must **encrypt** technicalVault before saving.  
* **Access:** Client

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "industry": "Real Estate",  
  "websiteUrl": "https://example.com",  
  "technicalVault": "Hosting: GoDaddy, User: admin, Pass: SuperSecret"  
}

---

##      **4\. Service Requests (Needs Assessment)**

*Implements FR-CL-002, FR-A-002*

### **Submit Request**

**POST** /requests

* **Description:** Client submits a new need. Status defaults to Pending Triage.  
* **Access:** Client

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "categoryId": 1,  
  "details": "I need a complete re-brand and a new website.",  
  "priority": "High"  
}

*  

### **List Requests**

**GET** /requests

* **Description:**  
  * **Admin:** Sees all Pending Triage requests.  
  * **Agent:** Sees requests assigned to them.  
  * **Client:** Sees only their own requests.  
*   
* **Access:** Authenticated (Logic depends on role)

### **Assign Agent (Triage)**

**PATCH** /requests/:id/assign

* **Description:** Assigns an agent to a request.  
* **Access:** Admin

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "agentId": 5  
}

* **Side Effect:** Updates status to Assigned.

## **5\. Proposals (Quotes)**

*Implements FR-AG-002, FR-CL-004*

### **Generate Proposal**

**POST** /proposals

* **Description:** Creates a proposal line-by-line. Generates PDF on server.  
* **Access:** Agent

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "requestId": 10,  
  "items": \[  
    { "description": "Homepage Design", "price": 1500 },  
    { "description": "SEO Setup", "price": 500 }  
  \]  
}

*    
* **Side Effect:** Updates Request status to Quoted.

### **Send Proposal**

**POST** /proposals/:id/send

* **Description:** Emails the PDF to the client.  
* **Access:** Agent  
* **Response:** { "message": "Proposal sent to client@example.com" }

### **Respond to Proposal (Accept/Reject)**

**PATCH** /proposals/:id/status

* **Description:** Client accepts or rejects the quote.  
* **Access:** Client  
* **Body:** { "status": "Accepted" }  
* **CRITICAL LOGIC:** If status is Accepted, the backend must automatically create a **Project** record.

##      **6\. Project Dashboard**

*Implements FR-AG-004, FR-CL-005*

### **List Projects**

**GET** /projects

* **Description:** List active projects.  
* **Access:** Client (Own), Agent (Assigned), Admin (All).

### **Update Project Status**

**PATCH** /projects/:id

* **Description:** Update tracking metrics.  
* **Access:** Agent

**Body:**  
 code JSON  
downloadcontent\_copy  
expand\_less  
    {  
  "globalStatus": "In Progress", // Enum: Pending, In Progress, Testing, Delivered  
  "progressPercent": 45,         // Integer 0-100  
  "ecd": "2025-12-25"            // Estimated Completion Date  
}

---

## **7\. Asset Management**

*Implements FR-CL-006, FR-AG-005*

### **Upload Asset**

**POST** /projects/:id/assets

* **Description:** Upload a file.  
* **Access:** Client, Agent  
* **Body:** Form-Data (file: binary)  
* **Query Param:** ?type=Deliverable or ?type=ClientAsset

### **List Assets**

**GET** /projects/:id/assets

* **Description:** Get list of files for a project.  
* **Access:** Client, Agent  
* **Response:** \[ { "fileName": "logo.png", "path": "/uploads/...", "type": "ClientAsset" } \]
</file>

<file path="package.json">
{
  "name": "biztech-digital-backend-api",
  "version": "1.0.0",
  "description": "Create uploads folder and inside it quotations folder, also check env if missing",
  "main": "index.js",
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mfaizan11/Biztech-Digital-Backend-Api.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/mfaizan11/Biztech-Digital-Backend-Api/issues"
  },
  "homepage": "https://github.com/mfaizan11/Biztech-Digital-Backend-Api#readme",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "express-validator": "^7.3.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.1",
    "multer": "^2.0.2",
    "mysql2": "^3.15.3",
    "nodemailer": "^7.0.11",
    "pdfkit": "^0.17.2",
    "sequelize": "^6.37.7"
  },
  "devDependencies": {
    "nodemon": "^3.1.11"
  }
}
</file>

<file path="src/api/proposal.routes.js">
const express = require('express');
const router = express.Router();
// Update imports to include sendProposal
const { createProposal, acceptProposal, sendProposal } = require('../controllers/proposal.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

router.post('/', protect, authorize('Agent'), createProposal);

// NEW ROUTE
router.post('/:id/send', protect, authorize('Agent'), sendProposal);

router.patch('/:id/accept', protect, authorize('Client'), acceptProposal);

module.exports = router;
</file>

<file path="src/api/request.routes.js">
const express = require('express');
const router = express.Router();
const { createRequest, getRequests, assignRequest } = require('../controllers/request.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

router.post('/', protect, authorize('Client'), createRequest);
router.get('/', protect, getRequests);
router.patch('/:id/assign', protect, authorize('Admin'), assignRequest);

module.exports = router;
</file>

<file path="src/config/database.js">
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false
  }
};
</file>

<file path="src/middleware/auth.middleware.js">
const jwt = require("jsonwebtoken");
const { User } = require("../models");

exports.protect = async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith("Bearer")) {
    token = req.headers.authorization.split(" ")[1];
  }

  if (!token) return res.status(401).json({ message: "Not authorized to access this route" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findByPk(decoded.id);

    if (!user) return res.status(404).json({ message: "User not found" });

    // Gatekeeper: Check Status
    if (user.status !== 'Active') {
        return res.status(403).json({ message: `Account is ${user.status}. Access Denied.` });
    }

    req.user = user;
    next();
  } catch (err) {
    return res.status(401).json({ message: "Not authorized, token failed" });
  }
};

exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: `Role ${req.user.role} is not authorized` });
    }
    next();
  };
};
</file>

<file path="src/middleware/error.middleware.js">
const errorMiddleware = (err, req, res, next) => {
    console.error(`‚ùå Error: ${err.message}`);
    const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
    res.status(statusCode).json({
        message: err.message,
        stack: process.env.NODE_ENV === 'production' ? null : err.stack,
    });
};

module.exports = { errorMiddleware };
</file>

<file path="src/middleware/upload.middleware.js">
const multer = require("multer");
const path = require("path");
const fs = require("fs");

// Ensure directories exist
const createDir = (dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
};

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let uploadPath = "uploads/assets"; // Default
    // You can segregate based on route or type if needed
    createDir(uploadPath);
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    // timestamp-filename.ext
    cb(null, `${Date.now()}-${file.originalname.replace(/\s+/g, '-')}`);
  },
});

const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|pdf|zip|rar|doc|docx/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname) {
    return cb(null, true);
  } else {
    cb(new Error("Error: File type not supported!"));
  }
};

const upload = multer({
  storage: storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: fileFilter,
});

module.exports = upload;
</file>

<file path="src/models/Client.js">
module.exports = (sequelize, DataTypes) => {
    const Client = sequelize.define('Client', {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        companyName: { type: DataTypes.STRING },
        industry: { type: DataTypes.STRING },
        websiteUrl: { type: DataTypes.STRING },
        technicalVault: { type: DataTypes.TEXT } // Stores Encrypted String
    });

    Client.associate = (models) => {
        Client.belongsTo(models.User, { foreignKey: 'userId', as: 'User' });
        Client.hasMany(models.ServiceRequest, { foreignKey: 'clientId', as: 'Requests' });
        Client.hasMany(models.Project, { foreignKey: 'clientId', as: 'Projects' });
    };
    return Client;
};
</file>

<file path="src/models/index.js">
const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require('../config/database')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (file.indexOf('.') !== 0) && (file !== basename) && (file.slice(-3) === '.js');
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
</file>

<file path="src/models/ProjectAsset.js">
module.exports = (sequelize, DataTypes) => {
    const ProjectAsset = sequelize.define('ProjectAsset', {
        filePath: { type: DataTypes.STRING, allowNull: false },
        fileName: { type: DataTypes.STRING },
        type: { type: DataTypes.ENUM('ClientAsset', 'Deliverable'), defaultValue: 'ClientAsset' }
    });
    ProjectAsset.associate = (models) => {
        ProjectAsset.belongsTo(models.Project, { foreignKey: 'projectId' });
    };
    return ProjectAsset;
};
</file>

<file path="src/models/ProjectNote.js">
module.exports = (sequelize, DataTypes) => {
    const ProjectNote = sequelize.define('ProjectNote', {
        content: { type: DataTypes.TEXT, allowNull: false }
    });

    ProjectNote.associate = (models) => {
        ProjectNote.belongsTo(models.Project, { foreignKey: 'projectId', as: 'Project' });
        ProjectNote.belongsTo(models.User, { foreignKey: 'userId', as: 'Author' });
    };
    return ProjectNote;
};
</file>

<file path="src/models/Proposal.js">
module.exports = (sequelize, DataTypes) => {
    const Proposal = sequelize.define('Proposal', {
        status: { 
            type: DataTypes.ENUM('Draft', 'Sent', 'Accepted', 'Rejected'),
            defaultValue: 'Draft' 
        },
        totalAmount: { type: DataTypes.DECIMAL(10, 2), defaultValue: 0.00 },
        pdfPath: { type: DataTypes.STRING }
    });

    Proposal.associate = (models) => {
        Proposal.belongsTo(models.ServiceRequest, { foreignKey: 'requestId', as: 'Request' });
        Proposal.belongsTo(models.User, { foreignKey: 'agentId', as: 'Agent' });
        Proposal.hasMany(models.ProposalLineItem, { foreignKey: 'proposalId', as: 'Items' });
    };
    return Proposal;
};
</file>

<file path="src/models/ProposalLineItem.js">
module.exports = (sequelize, DataTypes) => {
    const ProposalLineItem = sequelize.define('ProposalLineItem', {
        description: { type: DataTypes.STRING, allowNull: false },
        price: { type: DataTypes.DECIMAL(10, 2), allowNull: false }
    });
    ProposalLineItem.associate = (models) => {
        ProposalLineItem.belongsTo(models.Proposal, { foreignKey: 'proposalId' });
    };
    return ProposalLineItem;
};
</file>

<file path="src/models/ServiceCategory.js">
module.exports = (sequelize, DataTypes) => {
    const ServiceCategory = sequelize.define('ServiceCategory', {
        name: { type: DataTypes.STRING, allowNull: false, unique: true },
        description: { type: DataTypes.TEXT }
    });
    return ServiceCategory;
};
</file>

<file path="src/models/ServiceRequest.js">
module.exports = (sequelize, DataTypes) => {
    const ServiceRequest = sequelize.define('ServiceRequest', {
        details: { type: DataTypes.TEXT, allowNull: false },
        priority: { type: DataTypes.ENUM('Low', 'Medium', 'High'), defaultValue: 'Medium' },
        status: { 
            type: DataTypes.ENUM('Pending Triage', 'Assigned', 'Quoted', 'Converted', 'Rejected'),
            defaultValue: 'Pending Triage' 
        }
    });

    ServiceRequest.associate = (models) => {
        ServiceRequest.belongsTo(models.Client, { foreignKey: 'clientId', as: 'Client' });
        ServiceRequest.belongsTo(models.User, { foreignKey: 'agentId', as: 'AssignedAgent' });
        ServiceRequest.belongsTo(models.ServiceCategory, { foreignKey: 'categoryId', as: 'Category' });
        ServiceRequest.hasOne(models.Proposal, { foreignKey: 'requestId', as: 'Proposal' });
    };
    return ServiceRequest;
};
</file>

<file path="src/models/User.js">
module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define("User", {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    fullName: { type: DataTypes.STRING, allowNull: false },
    email: { type: DataTypes.STRING, allowNull: false, unique: true, validate: { isEmail: true } },
    password: { type: DataTypes.STRING, allowNull: false },
    role: { type: DataTypes.ENUM("Admin", "Agent", "Client"), allowNull: false },
    mobile: { type: DataTypes.STRING },
    status: { 
        type: DataTypes.ENUM('Pending Approval', 'Active', 'Rejected'),
        defaultValue: 'Pending Approval' 
    }
  });

  User.associate = (models) => {
    User.hasOne(models.Client, { foreignKey: "userId", as: "ClientProfile" });
    User.hasMany(models.ServiceRequest, { foreignKey: 'agentId', as: 'AssignedRequests' });
    User.hasMany(models.Project, { foreignKey: 'agentId', as: 'ManagedProjects' });
  };
  return User;
};
</file>

<file path="src/services/crypto.service.js">
const crypto = require('crypto');
const algorithm = 'aes-256-ctr';

// Ensure this key is exactly 32 chars in .env, or we hash it to force 32 bytes
const getKey = () => crypto.createHash('sha256').update(String(process.env.VAULT_SECRET)).digest('base64').substr(0, 32);

exports.encrypt = (text) => {
    if (!text) return null;
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, getKey(), iv);
    const encrypted = Buffer.concat([cipher.update(text), cipher.final()]);
    return `${iv.toString('hex')}:${encrypted.toString('hex')}`;
};

exports.decrypt = (hash) => {
    if (!hash) return null;
    const parts = hash.split(':');
    const iv = Buffer.from(parts.shift(), 'hex');
    const encryptedText = Buffer.from(parts.join(':'), 'hex');
    const decipher = crypto.createDecipheriv(algorithm, getKey(), iv);
    const decrypted = Buffer.concat([decipher.update(encryptedText), decipher.final()]);
    return decrypted.toString();
};
</file>

<file path="src/api/auth.routes.js">
const express = require('express');
const router = express.Router();
const { register, login, getMe, updateMe } = require('../controllers/auth.controller');
const { protect } = require('../middleware/auth.middleware');

router.post('/register', register);
router.post('/login', login);

// --- NEW ROUTES ---
router.get('/me', protect, getMe);
router.put('/me', protect, updateMe);

module.exports = router;
</file>

<file path="src/api/client.routes.js">
const express = require('express');
const router = express.Router();
const { getMyProfile, updateProfile, getAgentClients } = require('../controllers/client.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

router.get('/me', protect, authorize('Client'), getMyProfile);
router.put('/me', protect, authorize('Client'), updateProfile);

// --- NEW: Route for Agents to view their clients ---
router.get('/agent-list', protect, authorize('Agent'), getAgentClients);

module.exports = router;
</file>

<file path="src/api/project.routes.js">
const express = require('express');
const router = express.Router();
const { 
    getProjects, 
    getProject, 
    updateProjectStatus, 
    uploadAsset, 
    getAssets,
    getProjectVault,
    addNote,   // <-- Import this
    getNotes   // <-- Import this
} = require('../controllers/project.controller');
const { protect } = require('../middleware/auth.middleware');
const upload = require('../middleware/upload.middleware');

// Routes
router.get('/', protect, getProjects);
router.get('/:id', protect, getProject);
router.get('/:id/vault', protect, getProjectVault);
router.patch('/:id', protect, updateProjectStatus);

// Asset Routes
router.post('/:id/assets', protect, upload.single('file'), uploadAsset);
router.get('/:id/assets', protect, getAssets);

// --- NEW NOTE ROUTES ---
router.get('/:id/notes', protect, getNotes);
router.post('/:id/notes', protect, addNote);

module.exports = router;
</file>

<file path="src/controllers/auth.controller.js">
const db = require("../models");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const User = db.User;
const Client = db.Client;

exports.register = async (req, res, next) => {
  try {
    const { fullName, email, password, role, companyName, mobile } = req.body;

     // Prevent Agents/Admins from self-registering publicly
    if (role === 'Agent' || role === 'Admin') {
        return res.status(403).json({ 
            message: "Restricted role. Agents must be added by an Administrator." 
        });
    }
    
    // Check existing
    const exists = await User.findOne({ where: { email } });
    if (exists) return res.status(400).json({ message: "Email already exists" });

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const t = await db.sequelize.transaction();
    try {
        const user = await User.create({
            fullName, email, password: hashedPassword, role, mobile,
            status: 'Pending Approval' // Gated Access
        }, { transaction: t });

        if (role === 'Client') {
            await Client.create({ userId: user.id, companyName }, { transaction: t });
        }

        await t.commit();
        res.status(201).json({ message: "Registration successful. Please wait for Admin approval." });
    } catch (err) {
        await t.rollback();
        throw err;
    }
  } catch (error) { next(error); }
};

exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ where: { email } });

    if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(401).json({ message: "Invalid credentials" });
    }

    // Gatekeeper Check
    if (user.status !== 'Active') {
        return res.status(403).json({ message: `Account is ${user.status}. Contact Admin.` });
    }

    const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '30d' });
    res.json({ token, user: { id: user.id, name: user.fullName, role: user.role } });
  } catch (error) { next(error); }
};

// --- NEW: Get Current User Info ---
exports.getMe = async (req, res, next) => {
    try {
        const user = await User.findByPk(req.user.id, {
            attributes: { exclude: ['password'] }
        });
        if (!user) return res.status(404).json({ message: "User not found" });
        res.json(user);
    } catch (error) { next(error); }
};

// --- NEW: Update Current User Info ---
exports.updateMe = async (req, res, next) => {
    try {
        const { fullName, mobile, password } = req.body;
        const user = await User.findByPk(req.user.id);

        if (!user) return res.status(404).json({ message: "User not found" });

        if (fullName) user.fullName = fullName;
        if (mobile) user.mobile = mobile;
        if (password) {
            const salt = await bcrypt.genSalt(10);
            user.password = await bcrypt.hash(password, salt);
        }

        await user.save();
        
        res.json({ 
            message: "Profile updated successfully", 
            user: { id: user.id, name: user.fullName, email: user.email, role: user.role } 
        });
    } catch (error) { next(error); }
};
</file>

<file path="src/controllers/client.controller.js">
const db = require("../models");
const { encrypt, decrypt } = require("../services/crypto.service");
const Client = db.Client;
const Project = db.Project;
const User = db.User;

exports.getMyProfile = async (req, res, next) => {
    try {
        const profile = await Client.findOne({ where: { userId: req.user.id } });
        if (!profile) return res.status(404).json({ message: "Profile not found" });

        // Decrypt vault before sending
        if (profile.technicalVault) {
            profile.technicalVault = decrypt(profile.technicalVault);
        }
        res.json(profile);
    } catch (error) { next(error); }
};

exports.updateProfile = async (req, res, next) => {
    try {
        const { industry, websiteUrl, technicalVault } = req.body;
        const updateData = { industry, websiteUrl };
        
        // Encrypt vault if provided
        if (technicalVault) {
            updateData.technicalVault = encrypt(technicalVault);
        }

        await Client.update(updateData, { where: { userId: req.user.id } });
        res.json({ message: "Profile Updated" });
    } catch (error) { next(error); }
};

// --- NEW: Get Clients assigned to an Agent ---
exports.getAgentClients = async (req, res, next) => {
    try {
        // Find clients that have projects assigned to this agent
        const clients = await Client.findAll({
            include: [
                { 
                    model: User, 
                    as: 'User',
                    attributes: ['fullName', 'email'] 
                },
                {
                    model: Project,
                    as: 'Projects',
                    where: { agentId: req.user.id }, // Filter by Agent
                    attributes: ['id', 'globalStatus']
                }
            ]
        });

        // Format data for frontend
        const formattedClients = clients.map(c => ({
            id: c.id,
            name: c.User.fullName,
            email: c.User.email,
            company: c.companyName,
            industry: c.industry,
            projectsCount: c.Projects.length,
            activeProjects: c.Projects.filter(p => p.globalStatus === 'In Progress').length,
            joinedDate: c.createdAt
        }));

        res.json(formattedClients);
    } catch (error) { next(error); }
};
</file>

<file path="src/controllers/project.controller.js">
const db = require("../models");
const { decrypt } = require("../services/crypto.service");
const Project = db.Project;
const ProjectAsset = db.ProjectAsset;
const ProjectNote = db.ProjectNote; // Import Note Model
const Client = db.Client;
const User = db.User;

// List Projects (Filtered by Role)
exports.getProjects = async (req, res, next) => {
    try {
        let where = {};
        if (req.user.role === 'Client') {
            const client = await Client.findOne({ where: { userId: req.user.id } });
            if (client) where.clientId = client.id;
        } else if (req.user.role === 'Agent') {
            where.agentId = req.user.id;
        }
        
        const projects = await Project.findAll({ 
            where,
            include: ['Client', 'Request', 'Agent'] 
        });
        res.json(projects);
    } catch (error) { next(error); }
};

// Get Single Project Details
exports.getProject = async (req, res, next) => {
    try {
        const project = await Project.findByPk(req.params.id, {
            include: ['Client', 'Request', 'Agent', 'Assets']
        });

        if (!project) return res.status(404).json({ message: "Project not found" });

        // Security check: Agent
        if (req.user.role === 'Agent' && project.agentId !== req.user.id) {
            return res.status(403).json({ message: "Access denied" });
        }

        // Security check: Client
        if (req.user.role === 'Client') {
            const client = await Client.findOne({ where: { userId: req.user.id } });
            if (!client || project.clientId !== client.id) {
                return res.status(403).json({ message: "Access denied" });
            }
        }

        res.json(project);
    } catch (error) { next(error); }
};

// Get Project Vault (Credentials)
exports.getProjectVault = async (req, res, next) => {
    try {
        const project = await Project.findByPk(req.params.id, {
            include: ['Client']
        });

        if (!project) return res.status(404).json({ message: "Project not found" });

        // Security checks
        if (req.user.role === 'Agent' && project.agentId !== req.user.id) {
            return res.status(403).json({ message: "Access denied" });
        }
        if (req.user.role === 'Client') {
            const client = await Client.findOne({ where: { userId: req.user.id } });
            if (!client || project.clientId !== client.id) {
                return res.status(403).json({ message: "Access denied" });
            }
        }

        const vaultData = project.Client.technicalVault;
        const decryptedVault = vaultData ? decrypt(vaultData) : "No credentials stored.";

        res.json({ vault: decryptedVault });
    } catch (error) { next(error); }
};

// Update Project Status
exports.updateProjectStatus = async (req, res, next) => {
    try {
        await Project.update(req.body, { where: { id: req.params.id } });
        res.json({ message: "Project Updated" });
    } catch (error) { next(error); }
};

// Upload Asset
exports.uploadAsset = async (req, res, next) => {
    try {
        if (!req.file) return res.status(400).json({ message: "No file uploaded" });

        const projectId = req.params.id;
        const type = req.query.type || 'ClientAsset'; 

        const asset = await ProjectAsset.create({
            projectId,
            filePath: req.file.path,
            fileName: req.file.originalname,
            type
        });

        res.status(201).json(asset);
    } catch (error) { next(error); }
};

// Get Assets
exports.getAssets = async (req, res, next) => {
    try {
        const assets = await ProjectAsset.findAll({ 
            where: { projectId: req.params.id } 
        });
        res.json(assets);
    } catch (error) { next(error); }
};

// --- NEW FUNCTIONS FOR NOTES ---

exports.addNote = async (req, res, next) => {
    try {
        const { content } = req.body;
        const projectId = req.params.id;

        if (!content) return res.status(400).json({ message: "Content is required" });

        const note = await ProjectNote.create({
            projectId,
            userId: req.user.id,
            content
        });

        const fullNote = await ProjectNote.findByPk(note.id, {
            include: [{ model: User, as: 'Author', attributes: ['fullName', 'role'] }]
        });

        res.status(201).json(fullNote);
    } catch (error) { next(error); }
};

exports.getNotes = async (req, res, next) => {
    try {
        const notes = await ProjectNote.findAll({
            where: { projectId: req.params.id },
            include: [{ model: User, as: 'Author', attributes: ['fullName', 'role'] }],
            order: [['createdAt', 'ASC']]
        });
        res.json(notes);
    } catch (error) { next(error); }
};
</file>

<file path="src/controllers/proposal.controller.js">
const db = require("../models");
const { generateProposalPDF } = require("../services/pdf.service"); 
const { sendProposalEmail } = require("../services/email.service"); 
const Proposal = db.Proposal;
const ProposalLineItem = db.ProposalLineItem;
const ServiceRequest = db.ServiceRequest;
const Project = db.Project;
const Client = db.Client;

exports.createProposal = async (req, res, next) => {
    try {
        const { requestId, items } = req.body; 
        
        // Calculate Total
        const totalAmount = items.reduce((sum, item) => sum + Number(item.price), 0);

        const t = await db.sequelize.transaction();
        try {
            // Check if proposal exists and delete old one (to allow Re-create)
            await Proposal.destroy({ where: { requestId }, transaction: t });

            // 1. Create Proposal Record (Status: Draft)
            const proposal = await Proposal.create({
                requestId,
                agentId: req.user.id,
                totalAmount,
                status: 'Draft', // Explicitly Draft
                pdfPath: "pending..." 
            }, { transaction: t });

            // 2. Create Line Items
            const lineItems = items.map(i => ({ ...i, proposalId: proposal.id }));
            await ProposalLineItem.bulkCreate(lineItems, { transaction: t });

            // NOTE: We do NOT update ServiceRequest status to 'Quoted' yet. 
            // It remains 'Assigned' until the agent clicks "Send".

            // 3. Generate PDF
            const requestData = await ServiceRequest.findByPk(requestId, { include: ['Client'] });
            const clientName = requestData?.Client?.companyName || "Valued Client";

            const pdfPath = await generateProposalPDF(proposal.id, clientName, items, totalAmount);
            
            // Update PDF Path
            proposal.pdfPath = pdfPath;
            await proposal.save({ transaction: t });

            await t.commit();
            res.status(201).json(proposal);
        } catch (err) { await t.rollback(); throw err; }
    } catch (error) { next(error); }
};

exports.sendProposal = async (req, res, next) => {
    try {
        const proposalId = req.params.id;

        // Fetch proposal with Client info
        const proposal = await db.Proposal.findByPk(proposalId, {
            include: [
                { 
                    model: db.ServiceRequest, 
                    as: 'Request',
                    include: [{ model: db.Client, as: 'Client', include: ['User'] }] 
                }
            ]
        });

        if (!proposal) return res.status(404).json({ message: "Proposal not found" });
        if (!proposal.pdfPath) return res.status(400).json({ message: "PDF not generated yet" });

        const clientUser = proposal.Request.Client.User;
        const clientName = clientUser.fullName;
        const clientEmail = clientUser.email;

        // Send Email
        await sendProposalEmail(clientEmail, clientName, proposal.id, proposal.pdfPath);

        const t = await db.sequelize.transaction();
        try {
            // 1. Update Proposal Status
            await proposal.update({ status: 'Sent' }, { transaction: t });

            // 2. Update Request Status to 'Quoted' (This triggers the Client Dashboard view)
            await ServiceRequest.update(
                { status: 'Quoted' }, 
                { where: { id: proposal.requestId }, transaction: t }
            );

            await t.commit();
            res.json({ message: `Proposal sent to ${clientEmail} and Dashboard updated.` });
        } catch (err) { await t.rollback(); throw err; }

    } catch (error) { next(error); }
};

exports.acceptProposal = async (req, res, next) => {
    try {
        const proposal = await Proposal.findByPk(req.params.id, {
            include: [{ model: ServiceRequest, as: 'Request' }]
        });

        if (!proposal) return res.status(404).json({ message: "Proposal not found" });

        const t = await db.sequelize.transaction();
        try {
            // Update Proposal
            await proposal.update({ status: 'Accepted' }, { transaction: t });
            
            // Update Request
            await ServiceRequest.update({ status: 'Converted' }, { where: { id: proposal.requestId }, transaction: t });

            // CREATE PROJECT
            const project = await Project.create({
                requestId: proposal.requestId,
                clientId: proposal.Request.clientId,
                agentId: proposal.Request.agentId || req.user.id, 
                globalStatus: 'Pending'
            }, { transaction: t });

            await t.commit();
            res.json({ message: "Proposal Accepted & Project Started", projectId: project.id });
        } catch (err) { await t.rollback(); throw err; }
    } catch (error) { next(error); }
};
</file>

<file path="src/controllers/request.controller.js">
const db = require("../models");
const ServiceRequest = db.ServiceRequest;

exports.createRequest = async (req, res, next) => {
    try {
        const client = await db.Client.findOne({ where: { userId: req.user.id } });
        if (!client) return res.status(404).json({ message: "Client profile missing" });

        const request = await ServiceRequest.create({
            clientId: client.id,
            categoryId: req.body.categoryId,
            details: req.body.details,
            priority: req.body.priority
        });
        res.status(201).json(request);
    } catch (error) { next(error); }
};

exports.getRequests = async (req, res, next) => {
    try {
        let where = {};
        if (req.user.role === 'Client') {
            const client = await db.Client.findOne({ where: { userId: req.user.id } });
            where.clientId = client.id;
        } else if (req.user.role === 'Agent') {
            where.agentId = req.user.id;
        } else if (req.user.role === 'Admin') {
            where.status = 'Pending Triage'; // Admin triage view
        }

        const requests = await ServiceRequest.findAll({ 
            where, 
            include: ['Client', 'Category', 'AssignedAgent', 'Proposal'] // Added Proposal to include
        });
        res.json(requests);
    } catch (error) { next(error); }
};

exports.assignRequest = async (req, res, next) => {
    try {
        const { agentId } = req.body;
        await ServiceRequest.update(
            { agentId, status: 'Assigned' },
            { where: { id: req.params.id } }
        );
        res.json({ message: "Agent Assigned" });
    } catch (error) { next(error); }
};
</file>

<file path="src/models/Project.js">
module.exports = (sequelize, DataTypes) => {
    const Project = sequelize.define('Project', {
        globalStatus: { 
            type: DataTypes.ENUM('Pending', 'In Progress', 'Testing', 'Delivered'),
            defaultValue: 'Pending' 
        },
        progressPercent: { type: DataTypes.INTEGER, defaultValue: 0 },
        ecd: { type: DataTypes.DATEONLY },
    });

    Project.associate = (models) => {
        Project.belongsTo(models.ServiceRequest, { foreignKey: 'requestId', as: 'Request' });
        Project.belongsTo(models.Client, { foreignKey: 'clientId', as: 'Client' });
        Project.belongsTo(models.User, { foreignKey: 'agentId', as: 'Agent' });
        Project.hasMany(models.ProjectAsset, { foreignKey: 'projectId', as: 'Assets' });
        
        // --- NEW ASSOCIATION ---
        Project.hasMany(models.ProjectNote, { foreignKey: 'projectId', as: 'Notes' });
    };
    return Project;
};
</file>

<file path="src/services/email.service.js">
const nodemailer = require("nodemailer");
const path = require("path");
const fs = require("fs");

// Create Transporter
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: process.env.SMTP_PORT,
  secure: process.env.SMTP_SECURE === "false", // true for 465, false for other ports
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

// Generic Send Function
const sendEmail = async (to, subject, html, attachments = []) => {
  try {
    const info = await transporter.sendMail({
      from: `"${process.env.FROM_NAME}" <${process.env.FROM_EMAIL}>`,
      to,
      subject,
      html,
      attachments,
    });
    console.log("Message sent: %s", info.messageId);
    return info;
  } catch (error) {
    console.error("Error sending email:", error);
    throw new Error("Email service failed");
  }
};

// 1. Account Approval Email
exports.sendAccountApproval = async (email, name) => {
  const subject = "Your BizTech Account is Approved!";
  const html = `
    <h3>Hello ${name},</h3>
    <p>Great news! Your account has been approved by our administrators.</p>
    <p>You can now login to your dashboard to view services and submit requests.</p>
    <br>
    <p>Regards,<br>BizTech Team</p>
  `;
  return sendEmail(email, subject, html);
};

// 2. Send Proposal PDF
exports.sendProposalEmail = async (clientEmail, clientName, proposalId, pdfRelativePath) => {
  const subject = `Project Proposal #${proposalId} - Digitize Your Biz`;
  const html = `
    <h3>Hello ${clientName},</h3>
    <p>Please find attached the proposal for your requested services.</p>
    <p>You can review and accept this proposal directly from your dashboard.</p>
    <br>
    <p>Regards,<br>BizTech Team</p>
  `;

  // Resolve full path for attachment
  const fullPath = path.join(__dirname, "../../", pdfRelativePath);

  if (!fs.existsSync(fullPath)) {
    throw new Error("Proposal PDF file not found");
  }

  const attachments = [
    {
      filename: `Proposal-${proposalId}.pdf`,
      path: fullPath,
    },
  ];

  return sendEmail(clientEmail, subject, html, attachments);
};

// Export generic if needed elsewhere
exports.sendEmail = sendEmail;
</file>

<file path="src/services/pdf.service.js">
const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

exports.generateProposalPDF = (proposalId, clientName, items, totalAmount) => {
  return new Promise((resolve, reject) => {
    try {
      // Create document with margins
      const doc = new PDFDocument({ margin: 50, size: 'A4' });
      
      const fileName = `proposal-${proposalId}-${Date.now()}.pdf`;
      const uploadDir = path.join(__dirname, "../../uploads/proposals");
      
      // Ensure directory exists
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }

      const filePath = path.join(uploadDir, fileName);
      const writeStream = fs.createWriteStream(filePath);

      doc.pipe(writeStream);

      // --- THEME CONSTANTS ---
      const primaryColor = "#0D1B2A"; // Dark Blue
      const accentColor = "#2EC4B6";  // Teal
      const greyColor = "#4A5568";
      const lightGrey = "#F5F7FA";
      const white = "#FFFFFF";

      // --- HEADER SECTION ---
      // Draw top background rect
      doc.rect(0, 0, 595.28, 120).fill(primaryColor);
      
      // Company Name
      doc.fillColor(white).fontSize(26).font("Helvetica-Bold")
         .text("BizTech Biz Digital", 50, 40);
      
      // Subtitle
      doc.fillColor(accentColor).fontSize(10).font("Helvetica")
         .text("Agency Management Portal", 50, 75);

      // "PROPOSAL" Label
      doc.fillColor(white).fontSize(36).font("Helvetica-Bold")
         .text("PROPOSAL", 0, 40, { align: "right", width: 545.28 }); // 595 - 50 margin

      // --- INFO SECTION ---
      const yPos = 160;
      
      // Left Column: Prepared For
      doc.fillColor(greyColor).fontSize(10).font("Helvetica-Bold").text("PREPARED FOR", 50, yPos);
      doc.rect(50, yPos + 12, 200, 1).fill(accentColor); // Underline
      
      doc.fillColor(primaryColor).fontSize(12).font("Helvetica-Bold").text(clientName, 50, yPos + 25);
      doc.fillColor(greyColor).fontSize(10).font("Helvetica").text("Valued Client", 50, yPos + 40);

      // Right Column: Proposal Details
      doc.fillColor(greyColor).fontSize(10).font("Helvetica-Bold").text("PROPOSAL DETAILS", 350, yPos);
      doc.rect(350, yPos + 12, 195, 1).fill(accentColor); // Underline

      const detailsY = yPos + 25;
      doc.fillColor(primaryColor).fontSize(10).font("Helvetica-Bold");
      doc.text("Proposal ID:", 350, detailsY);
      doc.text("Date:", 350, detailsY + 15);
      doc.text("Valid Until:", 350, detailsY + 30);

      doc.fillColor(greyColor).font("Helvetica");
      doc.text(`#${proposalId}`, 450, detailsY, { align: 'right', width: 95 });
      doc.text(new Date().toLocaleDateString(), 450, detailsY + 15, { align: 'right', width: 95 });
      const validDate = new Date();
      validDate.setDate(validDate.getDate() + 14);
      doc.text(validDate.toLocaleDateString(), 450, detailsY + 30, { align: 'right', width: 95 });

      doc.moveDown(4);

      // --- TABLE SECTION ---
      const tableTop = 270;
      
      // Table Header Background
      doc.rect(50, tableTop, 495, 30).fill(primaryColor);
      
      // Table Header Text
      doc.fillColor(white).fontSize(10).font("Helvetica-Bold");
      doc.text("DESCRIPTION", 65, tableTop + 10);
      doc.text("AMOUNT", 450, tableTop + 10, { width: 90, align: "right" });

      // --- TABLE ITEMS ---
      let y = tableTop + 30;
      doc.font("Helvetica").fontSize(10);

      items.forEach((item, index) => {
        // Stripe background for alternate rows
        if (index % 2 === 0) {
            doc.rect(50, y, 495, 30).fill(lightGrey);
        } else {
            // Ensure white background implicitly or fill white if needed
        }

        // Reset fill color for text
        doc.fillColor("#333333");

        // Vertical alignment calculation
        const textY = y + 10;

        doc.text(item.description, 65, textY);
        doc.text(`$${Number(item.price).toFixed(2)}`, 450, textY, { width: 90, align: "right" });
        
        y += 30;
      });

      // Bottom line of table
      doc.rect(50, y, 495, 1).fill(greyColor);

      // --- TOTALS SECTION ---
      y += 20;
      const totalBoxTop = y;
      
      // Total Box Background
      doc.rect(350, totalBoxTop, 195, 45).fill(accentColor);
      
      doc.fillColor(primaryColor).fontSize(12).font("Helvetica-Bold");
      doc.text("TOTAL ESTIMATE", 370, totalBoxTop + 16);
      
      doc.fillColor(white).fontSize(16).font("Helvetica-Bold");
      doc.text(`$${Number(totalAmount).toFixed(2)}`, 450, totalBoxTop + 14, { width: 80, align: "right" });

      // --- FOOTER / TERMS ---
      const bottomPage = 680;
      
      doc.rect(50, bottomPage, 495, 2).fill(primaryColor);
      
      doc.fillColor(primaryColor).fontSize(11).font("Helvetica-Bold").text("Terms & Conditions", 50, bottomPage + 15);
      
      doc.fillColor(greyColor).fontSize(9).font("Helvetica")
         .text("1. A 50% deposit is required to commence work on the project.", 50, bottomPage + 30)
         .text("2. This proposal is valid for 14 days from the date of issue.", 50, bottomPage + 45)
         .text("3. All deliverables will be transferred upon final payment.", 50, bottomPage + 60);

      // Company Footer
      const footerY = 760;
      doc.rect(0, footerY, 595.28, 842 - footerY).fill(primaryColor); // Bottom bar
      
      doc.fillColor(white).fontSize(10).font("Helvetica-Bold")
         .text("BizTech Biz Digital", 0, footerY + 15, { align: "center" });
      
      doc.fillColor(accentColor).fontSize(9).font("Helvetica")
         .text("services@biztech.ae  |  +971 50 328 8786  |  www.biztech.ae", 0, footerY + 30, { align: "center" });

      doc.end();

      writeStream.on("finish", () => {
        // Return relative path for DB storage
        resolve(`uploads/proposals/${fileName}`);
      });

      writeStream.on("error", (err) => {
        reject(err);
      });
    } catch (error) {
      reject(error);
    }
  });
};
</file>

<file path="src/api/admin.routes.js">
const express = require('express');
const router = express.Router();
const { 
    getPendingUsers, 
    updateUserStatus, 
    createCategory, 
    getCategories, 
    updateCategory, // Added
    deleteCategory, // Added
    createAgent, 
    getAgents 
} = require('../controllers/admin.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

router.use(protect);

// Approval Routes
router.get('/users/pending', authorize('Admin'), getPendingUsers);
router.patch('/users/:id/status', authorize('Admin'), updateUserStatus);

// Category Routes
router.post('/categories', authorize('Admin'), createCategory);
router.get('/categories', getCategories);
router.put('/categories/:id', authorize('Admin'), updateCategory); // Added
router.delete('/categories/:id', authorize('Admin'), deleteCategory); // Added

// Agent Routes
router.post('/agents', authorize('Admin'), createAgent);
router.get('/agents', authorize('Admin'), getAgents);

module.exports = router;
</file>

<file path="src/controllers/admin.controller.js">
const bcrypt = require("bcryptjs"); 
const db = require("../models");
const User = db.User;
const ServiceCategory = db.ServiceCategory;
const { sendAccountApproval } = require('../services/email.service');

exports.getPendingUsers = async (req, res, next) => {
    try {
        const users = await User.findAll({ where: { status: 'Pending Approval' } });
        res.json(users);
    } catch (error) { next(error); }
};

exports.updateUserStatus = async (req, res, next) => {
    try {
        const { status } = req.body; 
        const userId = req.params.id;

        const user = await User.findByPk(userId); 
        
        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }
        
        await User.update({ status }, { where: { id: userId } });
        
        if (status === 'Active') {
            try {
                await sendAccountApproval(user.email, user.fullName);
            } catch (emailError) {
                console.warn(`‚ö†Ô∏è Warning: Failed to send approval email. Check SMTP settings.`);
            }
        }

        res.json({ message: `User status updated to ${status}` });
    } catch (error) { next(error); }
};

exports.createCategory = async (req, res, next) => {
    try {
        const category = await ServiceCategory.create(req.body);
        res.status(201).json(category);
    } catch (error) { next(error); }
};

exports.getCategories = async (req, res, next) => {
    try {
        const categories = await ServiceCategory.findAll();
        res.json(categories);
    } catch (error) { next(error); }
};

// --- NEW: Update Category ---
exports.updateCategory = async (req, res, next) => {
    try {
        const { name, description } = req.body;
        const category = await ServiceCategory.findByPk(req.params.id);
        
        if (!category) return res.status(404).json({ message: "Category not found" });

        await category.update({ name, description });
        res.json({ message: "Category updated successfully", category });
    } catch (error) { next(error); }
};

// --- NEW: Delete Category ---
exports.deleteCategory = async (req, res, next) => {
    try {
        const category = await ServiceCategory.findByPk(req.params.id);
        if (!category) return res.status(404).json({ message: "Category not found" });

        await category.destroy();
        res.json({ message: "Category deleted successfully" });
    } catch (error) { 
        // Handle Foreign Key constraint errors (if category is used in requests)
        if (error.name === 'SequelizeForeignKeyConstraintError') {
            return res.status(400).json({ message: "Cannot delete this service because it is currently assigned to existing client requests." });
        }
        next(error); 
    }
};

exports.getAgents = async (req, res, next) => {
    try {
        const agents = await User.findAll({ 
            where: { role: 'Agent' },
            attributes: { exclude: ['password'] } 
        });
        res.json(agents);
    } catch (error) { next(error); }
};

exports.createAgent = async (req, res, next) => {
    try {
        const { fullName, email, password, mobile } = req.body;

        const exists = await User.findOne({ where: { email } });
        if (exists) return res.status(400).json({ message: "Email already exists" });

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const agent = await User.create({
            fullName,
            email,
            password: hashedPassword,
            role: 'Agent',
            mobile,
            status: 'Active'
        });

        res.status(201).json({ 
            message: "Agent created successfully.", 
            agent: { id: agent.id, email: agent.email, name: agent.fullName } 
        });
    } catch (error) { next(error); }
};
</file>

</files>
